(ns edo
  (:require [clojure.math :as math]
            [clojure.set :as set]
            [interval]
            [number]
            [scale]
            [temperament]
            search
            var))

(defn mapping
  "Returns the best mapping of the given primes for the edo of size n."
  [n primes]
  (let [g (/ 1200 n)
        pset (set primes)]
    [(vec (for [p number/primes]
            (if (pset p)
              (math/round (/ (interval/cents p) g))
              nil)))]))

(defn as-temperament
  "Returns n-edo as a temperament, mapped for the given primes."
  [n primes]
  {:name (str n "edo")
   :mapping (mapping n primes)
   :generators [(float (/ 1200 n))]})

(defn in-subgroup
  "Return edos from min-size to max-size that map the given primes with
   acceptable accuracy."
  [[min-size max-size] primes]
  (let [rs (interval/subgroup var/*odd-limit* primes)]
    (->> (range min-size (inc max-size))
         (map (fn [n]
                (let [es (->> (as-temperament n primes)
                              (temperament/error-stats rs))]
                  {:edo n
                   :mean-error (:mean-error es)
                   :max-error (:max-error es)})))
         (filter #(< (:max-error %) var/*error-tolerance*)))))

(defn strip-nondecreasing-error
  "Given a return value from in-subgroup, strip edos without lower mean and max
   error than smaller edos."
  [edos]
  (loop [remaining edos
         found []
         record-max var/*error-tolerance*
         record-mean var/*error-tolerance*]
    (if (empty? remaining)
      found
      (recur (rest remaining)
             (if (and (< (:max-error (first remaining)) record-max)
                      (< (:mean-error (first remaining)) record-mean))
               (conj found (first remaining))
               found)
             (min record-max (:max-error (first remaining)))
             (min record-mean (:mean-error (first remaining)))))))

(defn best-in-subgroup
  "Return the best edos from min-size to max-size for the given primes."
  [[min-size max-size] primes]
  (->> (in-subgroup [min-size max-size] primes)
       strip-nondecreasing-error))

(defn moses
  "Return MOSes matching pred for n-edo, generated by each edostep below a
   half-octave."
  [n pred]
  (for [i (range 1 (/ n 2))]
    (let [g (* 1200 (/ 1 n) i)
          ms (scale/moses [1200 g] [5 24])]
      {:steps i
       :cents (float g)
       :all (map count ms)
       :matching (map count (filter pred ms))})))

(defn supporting
  "Return EDOs from xs supporting temperament t."
  [xs t]
  (let [ps (temperament/primes t)
        rs (interval/subgroup var/*odd-limit* ps)]
    (->> xs
         (keep (fn [n]
                 (let [e (edo/as-temperament n ps)]
                   (when (every? #(zero? (first %))
                                 (map #(temperament/tmap e %) (:commas t)))
                     (-> (temperament/error-stats rs e)
                         (select-keys [:mean-error :max-error])
                         (assoc :edo n))))))
         (filter #(< (:max-error %) var/*error-tolerance*))
         (sort-by :mean-error))))

(defn closest-match
  "Return the closest match to c cents in n-edo."
  [n c]
  (->> (for [i (range (inc n))]
         (* i (/ 1200 n)))
       (sort-by #(abs (- % c)))
       first
       float))

(defn approximating
  "Return edos between minsize and maxsize with an interval within 2 cents of
   c, sorted by increasing distance."
  [[minsize maxsize] c]
  (->> (for [n (range minsize (inc maxsize))]
         {:edo n
          :error (- (closest-match n c) c)})
       (sort-by (comp abs :error))
       (take-while #(< (abs (:error %)) 2))))

(defn collapse-modes
  "Eliminate scales which are modes of earlier scales in the coll."
  [ss]
  (->> ss (map scale/brightest-tetrachordal-mode) set))

(defn all-tetrachord-scales
  "Return all possible tetrachordal scales from edo n."
  [n]
  (let [t (as-temperament n [2 3])
        fourth (temperament/edosteps t 4/3)
        fifth (temperament/edosteps t 3/2)]
    (->> (for [second (range 1 (dec fourth))
               third (range (inc second) fourth)]
           [second third fourth fifth (+ second fifth) (+ third fifth) n])
         collapse-modes)))

(defn scale-triads
  "Return triads from each mode of scale s in edo temperament t."
  [t s]
  (for [m (scale/modes s)]
    (search/mode-triads (t :mapping) (map vector m))))

(defn as-auto-temperament
  "Returns a temperament for n-edo, auto-mapping as many primes as possible
   within the current odd limit and error tolerance, preferring least error."
  [n]
  (let [rs (interval/odd-limit var/*odd-limit*)]
    (->> (number/viable-subgroups)
         (map #(let [t (as-temperament n %)]
                 (assoc t :max-error
                        (:max-error (temperament/error-stats rs t)))))
         (filter #(< (:max-error %) var/*error-tolerance*))
         (scale/max-by #(vector (count (keep identity (first (:mapping %))))
                                (- (:max-error %)))))))

(defn notate
  "Return a list of valid notation strings for ratio r in edo n."
  [n r]
  (let [t (edo/as-temperament n (set/union #{2 3}
                                           (set (interval/primes r))))
        naturals (map-indexed (fn [i r]
                                {:degree (inc i)
                                 :steps (temperament/edosteps t r)
                                 :sharps 0
                                 :ups 0})
                              [1/1 9/8 81/64 4/3 3/2 27/16 243/128 2/1])
        apotome-steps (temperament/edosteps t 2187/2048)
        add-sharp (fn [n i]
                    (-> n
                        (update :sharps #(+ % i))
                        (update :steps #(+ % (* i apotome-steps)))))
        add-up (fn [n i]
                 (-> n
                     (update :ups #(+ % i))
                     (update :steps #(+ % i))))
        notes (mapcat (fn [n]
                        (for [sharps (if (#{1 4 5 8} (:degree n))
                                       [-1 0 1]
                                       [-2 -1 0 1])
                              ups [-1 0 1]]
                          (add-sharp (add-up n ups) sharps)))
                      naturals)
        r-steps (temperament/edosteps t r)]
    (->> notes
         (filter #(= r-steps (:steps %)))
         (map (fn [n]
                (let [quality (if (#{1 4 5 8} (:degree n))
                                (case (:sharps n)
                                  -1 "d"
                                  0 "P"
                                  1 "A")
                                (case (:sharps n)
                                  -2 "d"
                                  -1 "m"
                                  0 "M"
                                  1 "A"))
                      downs (apply str (map (fn [_] "v") (range (- (:ups n)))))
                      ups (apply str (map (fn [_] "^") (range (:ups n))))]
                  (str ups downs quality (:degree n))))))))

(comment
  (binding [var/*odd-limit* 15]
    (let [n 34]
      (->> (all-tetrachord-scales n)
           (map (fn [s]
                  (let [ts (scale-triads (as-auto-temperament n) s)]
                    {:scale s, :triads ts, :count (/ (count (flatten ts))
                                                     3)})))
           (sort-by :count)
           (take-last 3))))

  (->> (temperament/named "superpyth")
       :generators
       second
       (approximating [5 99]))

  (approximating [5 99] 163.743)

  (binding [var/*error-tolerance* 25]
    (supporting (range 5 51) {:mapping [[0 0 0 0 0 0]] :commas [1/1]}))

  (temperament/error-stats (interval/odd-limit 15)
                           (edo/as-auto-temperament 321))

  (->> (interval/odd-limit 15)
       (map #(vector % (set/intersection (set (notate 50 %))
                                         (set (notate 43 %))))))

  (binding [var/*error-tolerance* 20
            var/*odd-limit* 9]
    (best-in-subgroup [5 199] [2 3 5 7]))

  ; setting 81/80 = 64/63 = 65/64
  (edo/supporting (range 5 100)
                  (temperament/named "hemififths"))

  ; setting 81/80 = 64/63 = 65/64 = 55/54
  (edo/supporting (range 5 100)
                  {:mapping [[0 0 0 0 0 0]]
                   :commas [5120/5103 325/324 385/384]})

  (->> (temperament/named "hemififths planar")
       notation/all-planar
       (filter #(> (interval/limit (first %)) 7)))
  :rcf)
